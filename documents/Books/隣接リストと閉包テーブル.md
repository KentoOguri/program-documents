# 隣接リストと閉包テーブル
隣接リスト（Adjacency List）は、階層構造（ツリー構造）をリレーショナルデータベースで表現する最もシンプルで直感的な方法です。各ノードが自分の親ノードのIDを持つことで階層関係を表現します。

## 基本構造

### テーブル設計
```sql
CREATE TABLE categories (
    id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    parent_id INT,
    FOREIGN KEY (parent_id) REFERENCES categories(id)
);
```

### サンプルデータ
```sql
INSERT INTO categories VALUES
(1, 'Electronics', NULL),           -- ルート
  (2, 'Computers', 1),              -- Electronics の子
    (3, 'Laptops', 2),              -- Computers の子
    (4, 'Desktops', 2),             -- Computers の子
      (5, 'Gaming PCs', 4),         -- Desktops の子
      (6, 'Office PCs', 4),         -- Desktops の子
  (7, 'Smartphones', 1),            -- Electronics の子
    (8, 'Android', 7),              -- Smartphones の子
    (9, 'iPhone', 7),               -- Smartphones の子
(10, 'Books', NULL),                -- 別のルート
  (11, 'Programming', 10),          -- Books の子
    (12, 'Python', 11),             -- Programming の子
    (13, 'JavaScript', 11);         -- Programming の子
```

### 視覚的な構造
```
Electronics (1)
├── Computers (2)
│   ├── Laptops (3)
│   └── Desktops (4)
│       ├── Gaming PCs (5)
│       └── Office PCs (6)
└── Smartphones (7)
    ├── Android (8)
    └── iPhone (9)

Books (10)
└── Programming (11)
    ├── Python (12)
    └── JavaScript (13)
```

## 基本操作

### 1. 直接の子を取得
```sql
-- Computers (id=2) の直接の子カテゴリ
SELECT id, name 
FROM categories 
WHERE parent_id = 2;

-- 結果:
-- 3, Laptops
-- 4, Desktops
```

### 2. 親を取得
```sql
-- Gaming PCs (id=5) の親カテゴリ
SELECT parent.id, parent.name
FROM categories child
JOIN categories parent ON child.parent_id = parent.id
WHERE child.id = 5;

-- 結果:
-- 4, Desktops
```

### 3. ルートカテゴリを取得
```sql
-- ルートカテゴリ（親がないもの）
SELECT id, name 
FROM categories 
WHERE parent_id IS NULL;

-- 結果:
-- 1, Electronics
-- 10, Books
```

### 4. 葉ノード（子がないもの）を取得
```sql
-- 葉ノード
SELECT c1.id, c1.name
FROM categories c1
LEFT JOIN categories c2 ON c1.id = c2.parent_id
WHERE c2.id IS NULL;

-- 結果:
-- 3, Laptops
-- 5, Gaming PCs
-- 6, Office PCs
-- 8, Android
-- 9, iPhone
-- 12, Python
-- 13, JavaScript
```

## 隣接リストの深刻な問題

### 1. 階層全体の取得が困難

#### 問題：全ての子孫を取得したい場合
```sql
-- ❌ 悪い例：固定的な深さのみ対応
-- Electronics (id=1) の2階層下まで
SELECT c1.id as level1_id, c1.name as level1_name,
       c2.id as level2_id, c2.name as level2_name,
       c3.id as level3_id, c3.name as level3_name
FROM categories c1
LEFT JOIN categories c2 ON c1.id = c2.parent_id
LEFT JOIN categories c3 ON c2.id = c3.parent_id
WHERE c1.id = 1;
```

#### 再帰クエリでの解決（MySQL 8.0+, PostgreSQL）
```sql
-- ✅ 再帰CTE使用（MySQL 8.0+）
WITH RECURSIVE category_tree AS (
    -- ベースケース：指定されたノード
    SELECT id, name, parent_id, 0 as level, CAST(name AS CHAR(1000)) as path
    FROM categories 
    WHERE id = 1
    
    UNION ALL
    
    -- 再帰ケース：子ノードを追加
    SELECT c.id, c.name, c.parent_id, ct.level + 1, 
           CONCAT(ct.path, ' > ', c.name)
    FROM categories c
    JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT * FROM category_tree ORDER BY level, name;
```

### 2. 削除操作の複雑さ

#### 問題1：子を持つノードの削除
```sql
-- ❌ これは失敗する（外部キー制約違反）
DELETE FROM categories WHERE id = 2;  -- Computers
-- ERROR: Cannot delete or update a parent row: a foreign key constraint fails
```

#### 問題2：削除の選択肢と複雑さ
削除時には以下の選択肢があり、それぞれ複雑な処理が必要：

**A) カスケード削除（子孫も全て削除）**
```sql
-- 手動でのカスケード削除（危険）
-- 1. 最深レベルから順番に削除
DELETE FROM categories WHERE id IN (5, 6);  -- Gaming PCs, Office PCs
DELETE FROM categories WHERE id = 4;        -- Desktops
DELETE FROM categories WHERE id = 3;        -- Laptops  
DELETE FROM categories WHERE id = 2;        -- Computers

-- または、外部キー制約にCASCADEを設定
ALTER TABLE categories 
DROP FOREIGN KEY categories_ibfk_1;

ALTER TABLE categories 
ADD FOREIGN KEY (parent_id) REFERENCES categories(id) ON DELETE CASCADE;

DELETE FROM categories WHERE id = 2;  -- これで子孫も全て削除される
```

**B) 子を親に昇格（レベルを上げる）**
```sql
-- Computers を削除し、その子（Laptops, Desktops）をElectronicsの直下に移動
UPDATE categories 
SET parent_id = 1  -- Electronics
WHERE parent_id = 2;  -- Computers の子

DELETE FROM categories WHERE id = 2;
```

**C) 子を他のノードに移動**
```sql
-- Computers を削除し、その子をSmartphonesの下に移動
UPDATE categories 
SET parent_id = 7  -- Smartphones
WHERE parent_id = 2;  -- Computers の子

DELETE FROM categories WHERE id = 2;
```

### 3. パフォーマンスの問題

#### 深い階層での問題
```sql
-- 10階層の深いツリーで全ての祖先を取得
-- 非効率的な多重JOIN
SELECT c1.name as ancestor1, c2.name as ancestor2, c3.name as ancestor3,
       c4.name as ancestor4, c5.name as ancestor5, c6.name as ancestor6,
       c7.name as ancestor7, c8.name as ancestor8, c9.name as ancestor9,
       c10.name as current_node
FROM categories c10
LEFT JOIN categories c9 ON c10.parent_id = c9.id
LEFT JOIN categories c8 ON c9.parent_id = c8.id
LEFT JOIN categories c7 ON c8.parent_id = c7.id
LEFT JOIN categories c6 ON c7.parent_id = c6.id
LEFT JOIN categories c5 ON c6.parent_id = c5.id
LEFT JOIN categories c4 ON c5.parent_id = c4.id
LEFT JOIN categories c3 ON c4.parent_id = c3.id
LEFT JOIN categories c2 ON c3.parent_id = c2.id
LEFT JOIN categories c1 ON c2.parent_id = c1.id
WHERE c10.id = 12;
```

## 閉包テーブル（Closure Table）での解決

### 基本構造
```sql
-- 元のテーブル（シンプルに）
CREATE TABLE categories (
    id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

-- 閉包テーブル（全ての祖先-子孫関係を記録）
CREATE TABLE category_closure (
    ancestor_id INT NOT NULL,
    descendant_id INT NOT NULL,
    depth INT NOT NULL,
    PRIMARY KEY (ancestor_id, descendant_id),
    FOREIGN KEY (ancestor_id) REFERENCES categories(id) ON DELETE CASCADE,
    FOREIGN KEY (descendant_id) REFERENCES categories(id) ON DELETE CASCADE
);
```

### 閉包テーブルのデータ例
```sql
-- 各ノードの全ての祖先-子孫関係
INSERT INTO category_closure VALUES
-- 自分自身（depth = 0）
(1, 1, 0), (2, 2, 0), (3, 3, 0), (4, 4, 0), (5, 5, 0),
(6, 6, 0), (7, 7, 0), (8, 8, 0), (9, 9, 0),

-- Electronics (1) の子孫
(1, 2, 1),  -- Electronics > Computers
(1, 3, 2),  -- Electronics > Computers > Laptops
(1, 4, 2),  -- Electronics > Computers > Desktops
(1, 5, 3),  -- Electronics > Computers > Desktops > Gaming PCs
(1, 6, 3),  -- Electronics > Computers > Desktops > Office PCs
(1, 7, 1),  -- Electronics > Smartphones
(1, 8, 2),  -- Electronics > Smartphones > Android
(1, 9, 2),  -- Electronics > Smartphones > iPhone

-- Computers (2) の子孫
(2, 3, 1),  -- Computers > Laptops
(2, 4, 1),  -- Computers > Desktops
(2, 5, 2),  -- Computers > Desktops > Gaming PCs
(2, 6, 2),  -- Computers > Desktops > Office PCs

-- Desktops (4) の子孫
(4, 5, 1),  -- Desktops > Gaming PCs
(4, 6, 1),  -- Desktops > Office PCs

-- Smartphones (7) の子孫
(7, 8, 1),  -- Smartphones > Android
(7, 9, 1);  -- Smartphones > iPhone
```

### 閉包テーブルでの操作

#### 1. 全ての子孫を取得（簡単！）
```sql
-- Electronics (id=1) の全ての子孫
SELECT c.id, c.name, cc.depth
FROM categories c
JOIN category_closure cc ON c.id = cc.descendant_id
WHERE cc.ancestor_id = 1 AND cc.depth > 0
ORDER BY cc.depth, c.name;

-- 結果：
-- 2, Computers, 1
-- 7, Smartphones, 1
-- 3, Laptops, 2
-- 4, Desktops, 2
-- 8, Android, 2
-- 9, iPhone, 2
-- 5, Gaming PCs, 3
-- 6, Office PCs, 3
```

#### 2. 全ての祖先を取得（簡単！）
```sql
-- Gaming PCs (id=5) の全ての祖先
SELECT c.id, c.name, cc.depth
FROM categories c
JOIN category_closure cc ON c.id = cc.ancestor_id
WHERE cc.descendant_id = 5 AND cc.depth > 0
ORDER BY cc.depth DESC;

-- 結果：
-- 1, Electronics, 3
-- 2, Computers, 2
-- 4, Desktops, 1
```

#### 3. 直接の子を取得
```sql
-- Computers (id=2) の直接の子
SELECT c.id, c.name
FROM categories c
JOIN category_closure cc ON c.id = cc.descendant_id
WHERE cc.ancestor_id = 2 AND cc.depth = 1;

-- 結果：
-- 3, Laptops
-- 4, Desktops
```

#### 4. **削除が簡単！**
```sql
-- Computers (id=2) とその全ての子孫を削除
-- 1. 閉包テーブルから関連レコードを削除（CASCADE で自動）
-- 2. カテゴリを削除
DELETE FROM categories WHERE id = 2;

-- 外部キー制約のCASCADEにより、関連する閉包テーブルのレコードも自動削除される
```

### ノードの挿入
```sql
-- 新しいカテゴリ "Tablets" を Electronics の下に追加
INSERT INTO categories VALUES (14, 'Tablets');

-- 閉包テーブルに関係を追加
-- 1. 自分自身
INSERT INTO category_closure VALUES (14, 14, 0);

-- 2. 親（Electronics）の全ての祖先との関係
INSERT INTO category_closure (ancestor_id, descendant_id, depth)
SELECT ancestor_id, 14, depth + 1
FROM category_closure
WHERE descendant_id = 1;  -- Electronics のID
```

### ノードの移動
```sql
-- Laptops (id=3) を Smartphones (id=7) の下に移動

-- 1. 古い祖先関係を削除（自分自身以外）
DELETE FROM category_closure 
WHERE descendant_id = 3 AND ancestor_id != 3;

-- 2. 新しい祖先関係を追加
INSERT INTO category_closure (ancestor_id, descendant_id, depth)
SELECT ancestor_id, 3, depth + 1
FROM category_closure
WHERE descendant_id = 7;  -- 新しい親（Smartphones）
```

## 比較：隣接リスト vs 閉包テーブル

| 操作 | 隣接リスト | 閉包テーブル |
|------|------------|---------------|
| **ストレージ容量** | ⭐⭐⭐⭐⭐ 最小 | ⭐⭐ O(n²) |
| **直接の子取得** | ⭐⭐⭐⭐⭐ `WHERE parent_id = ?` | ⭐⭐⭐⭐ `WHERE ancestor_id = ? AND depth = 1` |
| **全ての子孫取得** | ⭐⭐ 再帰クエリ必要 | ⭐⭐⭐⭐⭐ `WHERE ancestor_id = ?` |
| **全ての祖先取得** | ⭐⭐ 再帰クエリ必要 | ⭐⭐⭐⭐⭐ `WHERE descendant_id = ?` |
| **ノード挿入** | ⭐⭐⭐⭐⭐ 1行 | ⭐⭐⭐ 祖先の数だけ行を追加 |
| **ノード削除** | ⭐ 非常に複雑 | ⭐⭐⭐⭐⭐ 1つのDELETE文 |
| **ノード移動** | ⭐⭐ 複雑な更新 | ⭐⭐⭐ 削除＋挿入 |
| **参照整合性** | ⭐⭐⭐ 外部キー可能 | ⭐⭐⭐⭐⭐ 完全な整合性保証 |

## 実用的な推奨事項

### 隣接リストを使う場合
- **浅い階層（2-3レベル）**のシンプルな構造
- **挿入が頻繁**で削除が稀
- **ストレージ容量**が非常に重要
- **再帰クエリ**が使用可能な環境

### 閉包テーブルを使う場合
- **深い階層**や複雑な構造
- **削除操作**が頻繁
- **階層クエリ**のパフォーマンスが重要
- **データの整合性**を重視
- **ツリー全体の操作**が多い


## まとめ

**隣接リストの削除が難しい理由**：
1. 子ノードとの参照整合性の問題
2. 削除方針（カスケード/移動/昇格）の決定が必要
3. 複雑な更新処理が必要

**閉包テーブルが削除に強い理由**：
1. CASCADE削除により関連データも自動削除
2. 階層関係が明示的に記録されている
3. 複雑な条件分岐が不要
